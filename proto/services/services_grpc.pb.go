// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.20.1
// source: services.proto

package services

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AuthenticateServiceClient is the client API for AuthenticateService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthenticateServiceClient interface {
	Authenticate(ctx context.Context, in *AuthorizeActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
}

type authenticateServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthenticateServiceClient(cc grpc.ClientConnInterface) AuthenticateServiceClient {
	return &authenticateServiceClient{cc}
}

func (c *authenticateServiceClient) Authenticate(ctx context.Context, in *AuthorizeActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.AuthenticateService/Authenticate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthenticateServiceServer is the server API for AuthenticateService service.
// All implementations must embed UnimplementedAuthenticateServiceServer
// for forward compatibility
type AuthenticateServiceServer interface {
	Authenticate(context.Context, *AuthorizeActionMsg) (*ActionResultMsg, error)
	mustEmbedUnimplementedAuthenticateServiceServer()
}

// UnimplementedAuthenticateServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAuthenticateServiceServer struct {
}

func (UnimplementedAuthenticateServiceServer) Authenticate(context.Context, *AuthorizeActionMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Authenticate not implemented")
}
func (UnimplementedAuthenticateServiceServer) mustEmbedUnimplementedAuthenticateServiceServer() {}

// UnsafeAuthenticateServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthenticateServiceServer will
// result in compilation errors.
type UnsafeAuthenticateServiceServer interface {
	mustEmbedUnimplementedAuthenticateServiceServer()
}

func RegisterAuthenticateServiceServer(s grpc.ServiceRegistrar, srv AuthenticateServiceServer) {
	s.RegisterService(&AuthenticateService_ServiceDesc, srv)
}

func _AuthenticateService_Authenticate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthorizeActionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticateServiceServer).Authenticate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthenticateService/Authenticate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticateServiceServer).Authenticate(ctx, req.(*AuthorizeActionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthenticateService_ServiceDesc is the grpc.ServiceDesc for AuthenticateService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthenticateService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.AuthenticateService",
	HandlerType: (*AuthenticateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Authenticate",
			Handler:    _AuthenticateService_Authenticate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}

// ResourceServiceClient is the client API for ResourceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ResourceServiceClient interface {
	AddTicket(ctx context.Context, in *TicketActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	DeleteTicket(ctx context.Context, in *TicketActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	CheckTicket(ctx context.Context, in *TicketActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	ListTickets(ctx context.Context, in *TicketActionMsg, opts ...grpc.CallOption) (ResourceService_ListTicketsClient, error)
	SetFlag(ctx context.Context, in *FlagActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	DestroyFlag(ctx context.Context, in *FlagActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	ListFlags(ctx context.Context, in *FlagActionMsg, opts ...grpc.CallOption) (ResourceService_ListFlagsClient, error)
}

type resourceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewResourceServiceClient(cc grpc.ClientConnInterface) ResourceServiceClient {
	return &resourceServiceClient{cc}
}

func (c *resourceServiceClient) AddTicket(ctx context.Context, in *TicketActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.ResourceService/AddTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourceServiceClient) DeleteTicket(ctx context.Context, in *TicketActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.ResourceService/DeleteTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourceServiceClient) CheckTicket(ctx context.Context, in *TicketActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.ResourceService/CheckTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourceServiceClient) ListTickets(ctx context.Context, in *TicketActionMsg, opts ...grpc.CallOption) (ResourceService_ListTicketsClient, error) {
	stream, err := c.cc.NewStream(ctx, &ResourceService_ServiceDesc.Streams[0], "/proto.ResourceService/ListTickets", opts...)
	if err != nil {
		return nil, err
	}
	x := &resourceServiceListTicketsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ResourceService_ListTicketsClient interface {
	Recv() (*TicketListResultMsg, error)
	grpc.ClientStream
}

type resourceServiceListTicketsClient struct {
	grpc.ClientStream
}

func (x *resourceServiceListTicketsClient) Recv() (*TicketListResultMsg, error) {
	m := new(TicketListResultMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *resourceServiceClient) SetFlag(ctx context.Context, in *FlagActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.ResourceService/SetFlag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourceServiceClient) DestroyFlag(ctx context.Context, in *FlagActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.ResourceService/DestroyFlag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourceServiceClient) ListFlags(ctx context.Context, in *FlagActionMsg, opts ...grpc.CallOption) (ResourceService_ListFlagsClient, error) {
	stream, err := c.cc.NewStream(ctx, &ResourceService_ServiceDesc.Streams[1], "/proto.ResourceService/ListFlags", opts...)
	if err != nil {
		return nil, err
	}
	x := &resourceServiceListFlagsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ResourceService_ListFlagsClient interface {
	Recv() (*FlagListResultMsg, error)
	grpc.ClientStream
}

type resourceServiceListFlagsClient struct {
	grpc.ClientStream
}

func (x *resourceServiceListFlagsClient) Recv() (*FlagListResultMsg, error) {
	m := new(FlagListResultMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ResourceServiceServer is the server API for ResourceService service.
// All implementations must embed UnimplementedResourceServiceServer
// for forward compatibility
type ResourceServiceServer interface {
	AddTicket(context.Context, *TicketActionMsg) (*ActionResultMsg, error)
	DeleteTicket(context.Context, *TicketActionMsg) (*ActionResultMsg, error)
	CheckTicket(context.Context, *TicketActionMsg) (*ActionResultMsg, error)
	ListTickets(*TicketActionMsg, ResourceService_ListTicketsServer) error
	SetFlag(context.Context, *FlagActionMsg) (*ActionResultMsg, error)
	DestroyFlag(context.Context, *FlagActionMsg) (*ActionResultMsg, error)
	ListFlags(*FlagActionMsg, ResourceService_ListFlagsServer) error
	mustEmbedUnimplementedResourceServiceServer()
}

// UnimplementedResourceServiceServer must be embedded to have forward compatible implementations.
type UnimplementedResourceServiceServer struct {
}

func (UnimplementedResourceServiceServer) AddTicket(context.Context, *TicketActionMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTicket not implemented")
}
func (UnimplementedResourceServiceServer) DeleteTicket(context.Context, *TicketActionMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTicket not implemented")
}
func (UnimplementedResourceServiceServer) CheckTicket(context.Context, *TicketActionMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckTicket not implemented")
}
func (UnimplementedResourceServiceServer) ListTickets(*TicketActionMsg, ResourceService_ListTicketsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListTickets not implemented")
}
func (UnimplementedResourceServiceServer) SetFlag(context.Context, *FlagActionMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetFlag not implemented")
}
func (UnimplementedResourceServiceServer) DestroyFlag(context.Context, *FlagActionMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyFlag not implemented")
}
func (UnimplementedResourceServiceServer) ListFlags(*FlagActionMsg, ResourceService_ListFlagsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListFlags not implemented")
}
func (UnimplementedResourceServiceServer) mustEmbedUnimplementedResourceServiceServer() {}

// UnsafeResourceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ResourceServiceServer will
// result in compilation errors.
type UnsafeResourceServiceServer interface {
	mustEmbedUnimplementedResourceServiceServer()
}

func RegisterResourceServiceServer(s grpc.ServiceRegistrar, srv ResourceServiceServer) {
	s.RegisterService(&ResourceService_ServiceDesc, srv)
}

func _ResourceService_AddTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TicketActionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourceServiceServer).AddTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ResourceService/AddTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourceServiceServer).AddTicket(ctx, req.(*TicketActionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourceService_DeleteTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TicketActionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourceServiceServer).DeleteTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ResourceService/DeleteTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourceServiceServer).DeleteTicket(ctx, req.(*TicketActionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourceService_CheckTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TicketActionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourceServiceServer).CheckTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ResourceService/CheckTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourceServiceServer).CheckTicket(ctx, req.(*TicketActionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourceService_ListTickets_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TicketActionMsg)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ResourceServiceServer).ListTickets(m, &resourceServiceListTicketsServer{stream})
}

type ResourceService_ListTicketsServer interface {
	Send(*TicketListResultMsg) error
	grpc.ServerStream
}

type resourceServiceListTicketsServer struct {
	grpc.ServerStream
}

func (x *resourceServiceListTicketsServer) Send(m *TicketListResultMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _ResourceService_SetFlag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlagActionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourceServiceServer).SetFlag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ResourceService/SetFlag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourceServiceServer).SetFlag(ctx, req.(*FlagActionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourceService_DestroyFlag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlagActionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourceServiceServer).DestroyFlag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ResourceService/DestroyFlag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourceServiceServer).DestroyFlag(ctx, req.(*FlagActionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourceService_ListFlags_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FlagActionMsg)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ResourceServiceServer).ListFlags(m, &resourceServiceListFlagsServer{stream})
}

type ResourceService_ListFlagsServer interface {
	Send(*FlagListResultMsg) error
	grpc.ServerStream
}

type resourceServiceListFlagsServer struct {
	grpc.ServerStream
}

func (x *resourceServiceListFlagsServer) Send(m *FlagListResultMsg) error {
	return x.ServerStream.SendMsg(m)
}

// ResourceService_ServiceDesc is the grpc.ServiceDesc for ResourceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ResourceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.ResourceService",
	HandlerType: (*ResourceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddTicket",
			Handler:    _ResourceService_AddTicket_Handler,
		},
		{
			MethodName: "DeleteTicket",
			Handler:    _ResourceService_DeleteTicket_Handler,
		},
		{
			MethodName: "CheckTicket",
			Handler:    _ResourceService_CheckTicket_Handler,
		},
		{
			MethodName: "SetFlag",
			Handler:    _ResourceService_SetFlag_Handler,
		},
		{
			MethodName: "DestroyFlag",
			Handler:    _ResourceService_DestroyFlag_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListTickets",
			Handler:       _ResourceService_ListTickets_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListFlags",
			Handler:       _ResourceService_ListFlags_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "services.proto",
}

// TaskServiceClient is the client API for TaskService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TaskServiceClient interface {
	OrderTask(ctx context.Context, in *TaskOrderMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	ForceTask(ctx context.Context, in *TaskOrderMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	OrderGroup(ctx context.Context, in *TaskOrderGroupMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	ForceGroup(ctx context.Context, in *TaskOrderGroupMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	EnforceTask(ctx context.Context, in *TaskActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	RerunTask(ctx context.Context, in *TaskActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	HoldTask(ctx context.Context, in *TaskActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	FreeTask(ctx context.Context, in *TaskActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	SetToOk(ctx context.Context, in *TaskActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	ConfirmTask(ctx context.Context, in *TaskActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	ListTasks(ctx context.Context, in *TaskFilterMsg, opts ...grpc.CallOption) (TaskService_ListTasksClient, error)
	TaskDetail(ctx context.Context, in *TaskActionMsg, opts ...grpc.CallOption) (*TaskDetailResultMsg, error)
	TaskOutput(ctx context.Context, in *TaskActionMsg, opts ...grpc.CallOption) (*TaskDataMsg, error)
	TaskLog(ctx context.Context, in *TaskActionMsg, opts ...grpc.CallOption) (*TaskDataMsg, error)
}

type taskServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTaskServiceClient(cc grpc.ClientConnInterface) TaskServiceClient {
	return &taskServiceClient{cc}
}

func (c *taskServiceClient) OrderTask(ctx context.Context, in *TaskOrderMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.TaskService/OrderTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) ForceTask(ctx context.Context, in *TaskOrderMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.TaskService/ForceTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) OrderGroup(ctx context.Context, in *TaskOrderGroupMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.TaskService/OrderGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) ForceGroup(ctx context.Context, in *TaskOrderGroupMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.TaskService/ForceGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) EnforceTask(ctx context.Context, in *TaskActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.TaskService/EnforceTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) RerunTask(ctx context.Context, in *TaskActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.TaskService/RerunTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) HoldTask(ctx context.Context, in *TaskActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.TaskService/HoldTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) FreeTask(ctx context.Context, in *TaskActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.TaskService/FreeTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) SetToOk(ctx context.Context, in *TaskActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.TaskService/SetToOk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) ConfirmTask(ctx context.Context, in *TaskActionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.TaskService/ConfirmTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) ListTasks(ctx context.Context, in *TaskFilterMsg, opts ...grpc.CallOption) (TaskService_ListTasksClient, error) {
	stream, err := c.cc.NewStream(ctx, &TaskService_ServiceDesc.Streams[0], "/proto.TaskService/ListTasks", opts...)
	if err != nil {
		return nil, err
	}
	x := &taskServiceListTasksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TaskService_ListTasksClient interface {
	Recv() (*TaskListResultMsg, error)
	grpc.ClientStream
}

type taskServiceListTasksClient struct {
	grpc.ClientStream
}

func (x *taskServiceListTasksClient) Recv() (*TaskListResultMsg, error) {
	m := new(TaskListResultMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *taskServiceClient) TaskDetail(ctx context.Context, in *TaskActionMsg, opts ...grpc.CallOption) (*TaskDetailResultMsg, error) {
	out := new(TaskDetailResultMsg)
	err := c.cc.Invoke(ctx, "/proto.TaskService/TaskDetail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) TaskOutput(ctx context.Context, in *TaskActionMsg, opts ...grpc.CallOption) (*TaskDataMsg, error) {
	out := new(TaskDataMsg)
	err := c.cc.Invoke(ctx, "/proto.TaskService/TaskOutput", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) TaskLog(ctx context.Context, in *TaskActionMsg, opts ...grpc.CallOption) (*TaskDataMsg, error) {
	out := new(TaskDataMsg)
	err := c.cc.Invoke(ctx, "/proto.TaskService/TaskLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TaskServiceServer is the server API for TaskService service.
// All implementations must embed UnimplementedTaskServiceServer
// for forward compatibility
type TaskServiceServer interface {
	OrderTask(context.Context, *TaskOrderMsg) (*ActionResultMsg, error)
	ForceTask(context.Context, *TaskOrderMsg) (*ActionResultMsg, error)
	OrderGroup(context.Context, *TaskOrderGroupMsg) (*ActionResultMsg, error)
	ForceGroup(context.Context, *TaskOrderGroupMsg) (*ActionResultMsg, error)
	EnforceTask(context.Context, *TaskActionMsg) (*ActionResultMsg, error)
	RerunTask(context.Context, *TaskActionMsg) (*ActionResultMsg, error)
	HoldTask(context.Context, *TaskActionMsg) (*ActionResultMsg, error)
	FreeTask(context.Context, *TaskActionMsg) (*ActionResultMsg, error)
	SetToOk(context.Context, *TaskActionMsg) (*ActionResultMsg, error)
	ConfirmTask(context.Context, *TaskActionMsg) (*ActionResultMsg, error)
	ListTasks(*TaskFilterMsg, TaskService_ListTasksServer) error
	TaskDetail(context.Context, *TaskActionMsg) (*TaskDetailResultMsg, error)
	TaskOutput(context.Context, *TaskActionMsg) (*TaskDataMsg, error)
	TaskLog(context.Context, *TaskActionMsg) (*TaskDataMsg, error)
	mustEmbedUnimplementedTaskServiceServer()
}

// UnimplementedTaskServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTaskServiceServer struct {
}

func (UnimplementedTaskServiceServer) OrderTask(context.Context, *TaskOrderMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderTask not implemented")
}
func (UnimplementedTaskServiceServer) ForceTask(context.Context, *TaskOrderMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForceTask not implemented")
}
func (UnimplementedTaskServiceServer) OrderGroup(context.Context, *TaskOrderGroupMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderGroup not implemented")
}
func (UnimplementedTaskServiceServer) ForceGroup(context.Context, *TaskOrderGroupMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForceGroup not implemented")
}
func (UnimplementedTaskServiceServer) EnforceTask(context.Context, *TaskActionMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnforceTask not implemented")
}
func (UnimplementedTaskServiceServer) RerunTask(context.Context, *TaskActionMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RerunTask not implemented")
}
func (UnimplementedTaskServiceServer) HoldTask(context.Context, *TaskActionMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HoldTask not implemented")
}
func (UnimplementedTaskServiceServer) FreeTask(context.Context, *TaskActionMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FreeTask not implemented")
}
func (UnimplementedTaskServiceServer) SetToOk(context.Context, *TaskActionMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetToOk not implemented")
}
func (UnimplementedTaskServiceServer) ConfirmTask(context.Context, *TaskActionMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmTask not implemented")
}
func (UnimplementedTaskServiceServer) ListTasks(*TaskFilterMsg, TaskService_ListTasksServer) error {
	return status.Errorf(codes.Unimplemented, "method ListTasks not implemented")
}
func (UnimplementedTaskServiceServer) TaskDetail(context.Context, *TaskActionMsg) (*TaskDetailResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaskDetail not implemented")
}
func (UnimplementedTaskServiceServer) TaskOutput(context.Context, *TaskActionMsg) (*TaskDataMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaskOutput not implemented")
}
func (UnimplementedTaskServiceServer) TaskLog(context.Context, *TaskActionMsg) (*TaskDataMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaskLog not implemented")
}
func (UnimplementedTaskServiceServer) mustEmbedUnimplementedTaskServiceServer() {}

// UnsafeTaskServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TaskServiceServer will
// result in compilation errors.
type UnsafeTaskServiceServer interface {
	mustEmbedUnimplementedTaskServiceServer()
}

func RegisterTaskServiceServer(s grpc.ServiceRegistrar, srv TaskServiceServer) {
	s.RegisterService(&TaskService_ServiceDesc, srv)
}

func _TaskService_OrderTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskOrderMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).OrderTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.TaskService/OrderTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).OrderTask(ctx, req.(*TaskOrderMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_ForceTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskOrderMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).ForceTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.TaskService/ForceTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).ForceTask(ctx, req.(*TaskOrderMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_OrderGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskOrderGroupMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).OrderGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.TaskService/OrderGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).OrderGroup(ctx, req.(*TaskOrderGroupMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_ForceGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskOrderGroupMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).ForceGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.TaskService/ForceGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).ForceGroup(ctx, req.(*TaskOrderGroupMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_EnforceTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskActionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).EnforceTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.TaskService/EnforceTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).EnforceTask(ctx, req.(*TaskActionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_RerunTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskActionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).RerunTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.TaskService/RerunTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).RerunTask(ctx, req.(*TaskActionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_HoldTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskActionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).HoldTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.TaskService/HoldTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).HoldTask(ctx, req.(*TaskActionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_FreeTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskActionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).FreeTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.TaskService/FreeTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).FreeTask(ctx, req.(*TaskActionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_SetToOk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskActionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).SetToOk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.TaskService/SetToOk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).SetToOk(ctx, req.(*TaskActionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_ConfirmTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskActionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).ConfirmTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.TaskService/ConfirmTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).ConfirmTask(ctx, req.(*TaskActionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_ListTasks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TaskFilterMsg)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TaskServiceServer).ListTasks(m, &taskServiceListTasksServer{stream})
}

type TaskService_ListTasksServer interface {
	Send(*TaskListResultMsg) error
	grpc.ServerStream
}

type taskServiceListTasksServer struct {
	grpc.ServerStream
}

func (x *taskServiceListTasksServer) Send(m *TaskListResultMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _TaskService_TaskDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskActionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).TaskDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.TaskService/TaskDetail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).TaskDetail(ctx, req.(*TaskActionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_TaskOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskActionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).TaskOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.TaskService/TaskOutput",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).TaskOutput(ctx, req.(*TaskActionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_TaskLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskActionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).TaskLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.TaskService/TaskLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).TaskLog(ctx, req.(*TaskActionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

// TaskService_ServiceDesc is the grpc.ServiceDesc for TaskService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TaskService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.TaskService",
	HandlerType: (*TaskServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OrderTask",
			Handler:    _TaskService_OrderTask_Handler,
		},
		{
			MethodName: "ForceTask",
			Handler:    _TaskService_ForceTask_Handler,
		},
		{
			MethodName: "OrderGroup",
			Handler:    _TaskService_OrderGroup_Handler,
		},
		{
			MethodName: "ForceGroup",
			Handler:    _TaskService_ForceGroup_Handler,
		},
		{
			MethodName: "EnforceTask",
			Handler:    _TaskService_EnforceTask_Handler,
		},
		{
			MethodName: "RerunTask",
			Handler:    _TaskService_RerunTask_Handler,
		},
		{
			MethodName: "HoldTask",
			Handler:    _TaskService_HoldTask_Handler,
		},
		{
			MethodName: "FreeTask",
			Handler:    _TaskService_FreeTask_Handler,
		},
		{
			MethodName: "SetToOk",
			Handler:    _TaskService_SetToOk_Handler,
		},
		{
			MethodName: "ConfirmTask",
			Handler:    _TaskService_ConfirmTask_Handler,
		},
		{
			MethodName: "TaskDetail",
			Handler:    _TaskService_TaskDetail_Handler,
		},
		{
			MethodName: "TaskOutput",
			Handler:    _TaskService_TaskOutput_Handler,
		},
		{
			MethodName: "TaskLog",
			Handler:    _TaskService_TaskLog_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListTasks",
			Handler:       _TaskService_ListTasks_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "services.proto",
}

// DefinitionServiceClient is the client API for DefinitionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DefinitionServiceClient interface {
	GetDefinition(ctx context.Context, in *DefinitionActionMsg, opts ...grpc.CallOption) (*DefinitionResultMsg, error)
	ListGroups(ctx context.Context, in *FilterMsg, opts ...grpc.CallOption) (*DefinitionListGroupResultMsg, error)
	ListDefinitionsFromGroup(ctx context.Context, in *GroupNameMsg, opts ...grpc.CallOption) (*DefinitionListResultMsg, error)
}

type definitionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDefinitionServiceClient(cc grpc.ClientConnInterface) DefinitionServiceClient {
	return &definitionServiceClient{cc}
}

func (c *definitionServiceClient) GetDefinition(ctx context.Context, in *DefinitionActionMsg, opts ...grpc.CallOption) (*DefinitionResultMsg, error) {
	out := new(DefinitionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.DefinitionService/GetDefinition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *definitionServiceClient) ListGroups(ctx context.Context, in *FilterMsg, opts ...grpc.CallOption) (*DefinitionListGroupResultMsg, error) {
	out := new(DefinitionListGroupResultMsg)
	err := c.cc.Invoke(ctx, "/proto.DefinitionService/ListGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *definitionServiceClient) ListDefinitionsFromGroup(ctx context.Context, in *GroupNameMsg, opts ...grpc.CallOption) (*DefinitionListResultMsg, error) {
	out := new(DefinitionListResultMsg)
	err := c.cc.Invoke(ctx, "/proto.DefinitionService/ListDefinitionsFromGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DefinitionServiceServer is the server API for DefinitionService service.
// All implementations must embed UnimplementedDefinitionServiceServer
// for forward compatibility
type DefinitionServiceServer interface {
	GetDefinition(context.Context, *DefinitionActionMsg) (*DefinitionResultMsg, error)
	ListGroups(context.Context, *FilterMsg) (*DefinitionListGroupResultMsg, error)
	ListDefinitionsFromGroup(context.Context, *GroupNameMsg) (*DefinitionListResultMsg, error)
	mustEmbedUnimplementedDefinitionServiceServer()
}

// UnimplementedDefinitionServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDefinitionServiceServer struct {
}

func (UnimplementedDefinitionServiceServer) GetDefinition(context.Context, *DefinitionActionMsg) (*DefinitionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDefinition not implemented")
}
func (UnimplementedDefinitionServiceServer) ListGroups(context.Context, *FilterMsg) (*DefinitionListGroupResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGroups not implemented")
}
func (UnimplementedDefinitionServiceServer) ListDefinitionsFromGroup(context.Context, *GroupNameMsg) (*DefinitionListResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDefinitionsFromGroup not implemented")
}
func (UnimplementedDefinitionServiceServer) mustEmbedUnimplementedDefinitionServiceServer() {}

// UnsafeDefinitionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DefinitionServiceServer will
// result in compilation errors.
type UnsafeDefinitionServiceServer interface {
	mustEmbedUnimplementedDefinitionServiceServer()
}

func RegisterDefinitionServiceServer(s grpc.ServiceRegistrar, srv DefinitionServiceServer) {
	s.RegisterService(&DefinitionService_ServiceDesc, srv)
}

func _DefinitionService_GetDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DefinitionActionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DefinitionServiceServer).GetDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.DefinitionService/GetDefinition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DefinitionServiceServer).GetDefinition(ctx, req.(*DefinitionActionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _DefinitionService_ListGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FilterMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DefinitionServiceServer).ListGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.DefinitionService/ListGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DefinitionServiceServer).ListGroups(ctx, req.(*FilterMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _DefinitionService_ListDefinitionsFromGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupNameMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DefinitionServiceServer).ListDefinitionsFromGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.DefinitionService/ListDefinitionsFromGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DefinitionServiceServer).ListDefinitionsFromGroup(ctx, req.(*GroupNameMsg))
	}
	return interceptor(ctx, in, info, handler)
}

// DefinitionService_ServiceDesc is the grpc.ServiceDesc for DefinitionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DefinitionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.DefinitionService",
	HandlerType: (*DefinitionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDefinition",
			Handler:    _DefinitionService_GetDefinition_Handler,
		},
		{
			MethodName: "ListGroups",
			Handler:    _DefinitionService_ListGroups_Handler,
		},
		{
			MethodName: "ListDefinitionsFromGroup",
			Handler:    _DefinitionService_ListDefinitionsFromGroup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}

// AdministrationServiceClient is the client API for AdministrationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AdministrationServiceClient interface {
	CreateUser(ctx context.Context, in *CreateUserMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	ModifyUser(ctx context.Context, in *CreateUserMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	DeleteUser(ctx context.Context, in *UserMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	ListUsers(ctx context.Context, in *FilterMsg, opts ...grpc.CallOption) (*ListEntityResultMsg, error)
	GetUser(ctx context.Context, in *UserMsg, opts ...grpc.CallOption) (*UserResultMsg, error)
	CreateRole(ctx context.Context, in *RoleDefinitionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	ModifyRole(ctx context.Context, in *RoleDefinitionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	DeleteRole(ctx context.Context, in *RoleMsg, opts ...grpc.CallOption) (*ActionResultMsg, error)
	ListRoles(ctx context.Context, in *FilterMsg, opts ...grpc.CallOption) (*ListEntityResultMsg, error)
	GetRole(ctx context.Context, in *RoleMsg, opts ...grpc.CallOption) (*RoleResultMsg, error)
	Quiesce(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ActionResultMsg, error)
	Resume(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ActionResultMsg, error)
}

type administrationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAdministrationServiceClient(cc grpc.ClientConnInterface) AdministrationServiceClient {
	return &administrationServiceClient{cc}
}

func (c *administrationServiceClient) CreateUser(ctx context.Context, in *CreateUserMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.AdministrationService/CreateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *administrationServiceClient) ModifyUser(ctx context.Context, in *CreateUserMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.AdministrationService/ModifyUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *administrationServiceClient) DeleteUser(ctx context.Context, in *UserMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.AdministrationService/DeleteUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *administrationServiceClient) ListUsers(ctx context.Context, in *FilterMsg, opts ...grpc.CallOption) (*ListEntityResultMsg, error) {
	out := new(ListEntityResultMsg)
	err := c.cc.Invoke(ctx, "/proto.AdministrationService/ListUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *administrationServiceClient) GetUser(ctx context.Context, in *UserMsg, opts ...grpc.CallOption) (*UserResultMsg, error) {
	out := new(UserResultMsg)
	err := c.cc.Invoke(ctx, "/proto.AdministrationService/GetUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *administrationServiceClient) CreateRole(ctx context.Context, in *RoleDefinitionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.AdministrationService/CreateRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *administrationServiceClient) ModifyRole(ctx context.Context, in *RoleDefinitionMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.AdministrationService/ModifyRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *administrationServiceClient) DeleteRole(ctx context.Context, in *RoleMsg, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.AdministrationService/DeleteRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *administrationServiceClient) ListRoles(ctx context.Context, in *FilterMsg, opts ...grpc.CallOption) (*ListEntityResultMsg, error) {
	out := new(ListEntityResultMsg)
	err := c.cc.Invoke(ctx, "/proto.AdministrationService/ListRoles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *administrationServiceClient) GetRole(ctx context.Context, in *RoleMsg, opts ...grpc.CallOption) (*RoleResultMsg, error) {
	out := new(RoleResultMsg)
	err := c.cc.Invoke(ctx, "/proto.AdministrationService/GetRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *administrationServiceClient) Quiesce(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.AdministrationService/Quiesce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *administrationServiceClient) Resume(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.AdministrationService/Resume", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AdministrationServiceServer is the server API for AdministrationService service.
// All implementations must embed UnimplementedAdministrationServiceServer
// for forward compatibility
type AdministrationServiceServer interface {
	CreateUser(context.Context, *CreateUserMsg) (*ActionResultMsg, error)
	ModifyUser(context.Context, *CreateUserMsg) (*ActionResultMsg, error)
	DeleteUser(context.Context, *UserMsg) (*ActionResultMsg, error)
	ListUsers(context.Context, *FilterMsg) (*ListEntityResultMsg, error)
	GetUser(context.Context, *UserMsg) (*UserResultMsg, error)
	CreateRole(context.Context, *RoleDefinitionMsg) (*ActionResultMsg, error)
	ModifyRole(context.Context, *RoleDefinitionMsg) (*ActionResultMsg, error)
	DeleteRole(context.Context, *RoleMsg) (*ActionResultMsg, error)
	ListRoles(context.Context, *FilterMsg) (*ListEntityResultMsg, error)
	GetRole(context.Context, *RoleMsg) (*RoleResultMsg, error)
	Quiesce(context.Context, *emptypb.Empty) (*ActionResultMsg, error)
	Resume(context.Context, *emptypb.Empty) (*ActionResultMsg, error)
	mustEmbedUnimplementedAdministrationServiceServer()
}

// UnimplementedAdministrationServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAdministrationServiceServer struct {
}

func (UnimplementedAdministrationServiceServer) CreateUser(context.Context, *CreateUserMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedAdministrationServiceServer) ModifyUser(context.Context, *CreateUserMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyUser not implemented")
}
func (UnimplementedAdministrationServiceServer) DeleteUser(context.Context, *UserMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedAdministrationServiceServer) ListUsers(context.Context, *FilterMsg) (*ListEntityResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUsers not implemented")
}
func (UnimplementedAdministrationServiceServer) GetUser(context.Context, *UserMsg) (*UserResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedAdministrationServiceServer) CreateRole(context.Context, *RoleDefinitionMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRole not implemented")
}
func (UnimplementedAdministrationServiceServer) ModifyRole(context.Context, *RoleDefinitionMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyRole not implemented")
}
func (UnimplementedAdministrationServiceServer) DeleteRole(context.Context, *RoleMsg) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRole not implemented")
}
func (UnimplementedAdministrationServiceServer) ListRoles(context.Context, *FilterMsg) (*ListEntityResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRoles not implemented")
}
func (UnimplementedAdministrationServiceServer) GetRole(context.Context, *RoleMsg) (*RoleResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRole not implemented")
}
func (UnimplementedAdministrationServiceServer) Quiesce(context.Context, *emptypb.Empty) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Quiesce not implemented")
}
func (UnimplementedAdministrationServiceServer) Resume(context.Context, *emptypb.Empty) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Resume not implemented")
}
func (UnimplementedAdministrationServiceServer) mustEmbedUnimplementedAdministrationServiceServer() {}

// UnsafeAdministrationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AdministrationServiceServer will
// result in compilation errors.
type UnsafeAdministrationServiceServer interface {
	mustEmbedUnimplementedAdministrationServiceServer()
}

func RegisterAdministrationServiceServer(s grpc.ServiceRegistrar, srv AdministrationServiceServer) {
	s.RegisterService(&AdministrationService_ServiceDesc, srv)
}

func _AdministrationService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdministrationServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AdministrationService/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdministrationServiceServer).CreateUser(ctx, req.(*CreateUserMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdministrationService_ModifyUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdministrationServiceServer).ModifyUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AdministrationService/ModifyUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdministrationServiceServer).ModifyUser(ctx, req.(*CreateUserMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdministrationService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdministrationServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AdministrationService/DeleteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdministrationServiceServer).DeleteUser(ctx, req.(*UserMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdministrationService_ListUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FilterMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdministrationServiceServer).ListUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AdministrationService/ListUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdministrationServiceServer).ListUsers(ctx, req.(*FilterMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdministrationService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdministrationServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AdministrationService/GetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdministrationServiceServer).GetUser(ctx, req.(*UserMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdministrationService_CreateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleDefinitionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdministrationServiceServer).CreateRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AdministrationService/CreateRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdministrationServiceServer).CreateRole(ctx, req.(*RoleDefinitionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdministrationService_ModifyRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleDefinitionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdministrationServiceServer).ModifyRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AdministrationService/ModifyRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdministrationServiceServer).ModifyRole(ctx, req.(*RoleDefinitionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdministrationService_DeleteRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdministrationServiceServer).DeleteRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AdministrationService/DeleteRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdministrationServiceServer).DeleteRole(ctx, req.(*RoleMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdministrationService_ListRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FilterMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdministrationServiceServer).ListRoles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AdministrationService/ListRoles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdministrationServiceServer).ListRoles(ctx, req.(*FilterMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdministrationService_GetRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdministrationServiceServer).GetRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AdministrationService/GetRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdministrationServiceServer).GetRole(ctx, req.(*RoleMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdministrationService_Quiesce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdministrationServiceServer).Quiesce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AdministrationService/Quiesce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdministrationServiceServer).Quiesce(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdministrationService_Resume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdministrationServiceServer).Resume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AdministrationService/Resume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdministrationServiceServer).Resume(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// AdministrationService_ServiceDesc is the grpc.ServiceDesc for AdministrationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AdministrationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.AdministrationService",
	HandlerType: (*AdministrationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _AdministrationService_CreateUser_Handler,
		},
		{
			MethodName: "ModifyUser",
			Handler:    _AdministrationService_ModifyUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _AdministrationService_DeleteUser_Handler,
		},
		{
			MethodName: "ListUsers",
			Handler:    _AdministrationService_ListUsers_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _AdministrationService_GetUser_Handler,
		},
		{
			MethodName: "CreateRole",
			Handler:    _AdministrationService_CreateRole_Handler,
		},
		{
			MethodName: "ModifyRole",
			Handler:    _AdministrationService_ModifyRole_Handler,
		},
		{
			MethodName: "DeleteRole",
			Handler:    _AdministrationService_DeleteRole_Handler,
		},
		{
			MethodName: "ListRoles",
			Handler:    _AdministrationService_ListRoles_Handler,
		},
		{
			MethodName: "GetRole",
			Handler:    _AdministrationService_GetRole_Handler,
		},
		{
			MethodName: "Quiesce",
			Handler:    _AdministrationService_Quiesce_Handler,
		},
		{
			MethodName: "Resume",
			Handler:    _AdministrationService_Resume_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}

// StatusServiceClient is the client API for StatusService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StatusServiceClient interface {
	OverseerStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ActionResultMsg, error)
}

type statusServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStatusServiceClient(cc grpc.ClientConnInterface) StatusServiceClient {
	return &statusServiceClient{cc}
}

func (c *statusServiceClient) OverseerStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ActionResultMsg, error) {
	out := new(ActionResultMsg)
	err := c.cc.Invoke(ctx, "/proto.StatusService/OverseerStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StatusServiceServer is the server API for StatusService service.
// All implementations must embed UnimplementedStatusServiceServer
// for forward compatibility
type StatusServiceServer interface {
	OverseerStatus(context.Context, *emptypb.Empty) (*ActionResultMsg, error)
	mustEmbedUnimplementedStatusServiceServer()
}

// UnimplementedStatusServiceServer must be embedded to have forward compatible implementations.
type UnimplementedStatusServiceServer struct {
}

func (UnimplementedStatusServiceServer) OverseerStatus(context.Context, *emptypb.Empty) (*ActionResultMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OverseerStatus not implemented")
}
func (UnimplementedStatusServiceServer) mustEmbedUnimplementedStatusServiceServer() {}

// UnsafeStatusServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StatusServiceServer will
// result in compilation errors.
type UnsafeStatusServiceServer interface {
	mustEmbedUnimplementedStatusServiceServer()
}

func RegisterStatusServiceServer(s grpc.ServiceRegistrar, srv StatusServiceServer) {
	s.RegisterService(&StatusService_ServiceDesc, srv)
}

func _StatusService_OverseerStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServiceServer).OverseerStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.StatusService/OverseerStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServiceServer).OverseerStatus(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// StatusService_ServiceDesc is the grpc.ServiceDesc for StatusService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StatusService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.StatusService",
	HandlerType: (*StatusServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OverseerStatus",
			Handler:    _StatusService_OverseerStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}
